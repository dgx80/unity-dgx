//
// Actor.cs
//
// Author:
//       Jean-Pierre Bouchard<>
//
// Copyright (c) 2015 Razan
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//     Version du runtime :4.0.30319.42000
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;
using DGX.Character.Controller;

namespace DGX.Character.Actor
{
    public class ActorBase : ScriptableObject
    {   
        //public
        public int health = 200;
        public float runSpeed = 7;
        public GameObject skeleton;
            
        //private
        private Animator mAnimator;
        private UnityEngine.Camera mCamera;
        private bool mJump = false;
        //to start jump action
        private bool mOnJump = false;
        private ScalableSpeed mScalableSpeed;
        
        static int idleState = Animator.StringToHash("Base Layer.idle");
        static int moveState = Animator.StringToHash("Base Layer.moving");
        static int jumpState = Animator.StringToHash("Base Layer.run-jump");
        
        private ActorStateMachine mStateMachine;
        private CharacterController mCharacterController;
        private CapsuleCollider mCollider;
        private AnimationCurve colliderHeightCurve;
        private int mCurrentBaseState;
            
        // Use this for initialization
        protected override void init ()
        {
            base.init ();
            mAnimator = GetComponentInChildren<Animator> ();
            mCharacterController = GetComponent<CharacterController>();
            mCollider = GetComponent<CapsuleCollider>();
            
            if (mScalableSpeed == null) {
                mScalableSpeed = new ScalableSpeed(1.0f);
            }
            mScalableSpeed.MAX_SPEED = runSpeed;
            
            mStateMachine = new ActorStateMachine(this, mScalableSpeed);
            mStateMachine.DEBUG = true;
            setSpeedForward(0f);
            
            //Vector3 c = GetComponent<CharacterController>().center;
            //GetComponent<CharacterController>().center = new Vector3(c.x, 10f, c.z);
        }
        
        // Update is called once per frame
        public virtual void Update ()
        {
            handleState();
            //GetComponent<Rigidbody>().AddForce( new Vector3(0f, 100f,0f));
            if (mCurrentBaseState != jumpState) {
                JUMP = mOnJump;
            }
        }
        
        void FixedUpdate()
        {
            float colliderHeight = mAnimator.GetFloat("ColliderHeight");
            float h = transform.position.y + colliderHeight;
            LOGGER.logTag("ColliderHeight", colliderHeight);
            LOGGER.logTag("h", h);
            
            if (mCurrentBaseState != jumpState) {
                
            } else {
                mOnJump = false;
                
                //LOGGER.logTag("x", skeleton.transform.position.x);
                
                //LOGGER.logTag("z", skeleton.transform.position.z);
                //LOGGER.logTag("h", h);
                
                
                Vector3 center = new Vector3(0f, 1f + colliderHeight, 0f);
                mCharacterController.center = center;
            }
        }
        
        public void onMoveTo(UnityEngine.Vector3 position)
        {
        }
        public void onJump()
        {
            mOnJump = true;
        }
        public void getHit(int damage)
        {
            if (health > 0) {
                health -= damage;
                if (health <= 0) {
                    health = 0;
                }
            }
            LOGGER.logTag ("health", health);
        }
        public bool Initialized()
        {
            return true;
        }
        protected void setSpeedForward(float speed)
        {
            if (mJump != true) {
                mAnimator.SetFloat("speedForward", speed);
                if (speed > 0.0f) {
                    mStateMachine.onMoving();
                }
            }
        }
        
        protected void updateRotation(Vector3 direction)
        {
            mStateMachine.updateRotation(direction);
        }
        
        private void handleState()
        {
            //LOGGER.logTag("y", skeleton.transform.position.y.ToString());
            AnimatorStateInfo info  = ANIMATOR.GetCurrentAnimatorStateInfo(0);
            mCurrentBaseState = info.fullPathHash;
            if (mScalableSpeed.SPEED <= 0.0f) {
                if (mCurrentBaseState == idleState)
                {
                    mStateMachine.onIdle();
                }else if (mCurrentBaseState == jumpState) {
                    mStateMachine.onJump();
                }
            }
            
            if (mCurrentBaseState != jumpState) {
                JUMP = mOnJump;
            } else {
                mOnJump = false;
                //float colliderHeight = mAnimator.GetFloat("ColliderHeight");
                //float h = transform.position.y + colliderHeight;
                //LOGGER.logTag("ColliderHeight", colliderHeight);
                //LOGGER.logTag("x", skeleton.transform.position.x);
                
                //LOGGER.logTag("z", skeleton.transform.position.z);
                //LOGGER.logTag("h", h);
                
                //Vector3 center = mCharacterController.transform.localPosition;
                //center = new Vector3(center.x, h, center.z);
               // mCharacterController.transform.localPosition = center;
            }
            mStateMachine.handleUpdate();
        }
        private bool JUMP
        {
            get { return mJump;}
            set
            {
                if (mJump != value) {
                    mJump = value;
                    mAnimator.SetBool("jump", value);
                }
                if(mJump) {
                    Invoke("stopJump", 0.4f);
                }
                    
            }
        }
        void stopJump()
        {
            mOnJump = false;
            JUMP = false;
        }
        protected Animator ANIMATOR
        {
            get { return mAnimator;}
        }
        protected ScalableSpeed SCALABLE_SPEED
        {
            set 
            {
                mScalableSpeed = value;
            }
            get {return mScalableSpeed;}
        }
    }   
}